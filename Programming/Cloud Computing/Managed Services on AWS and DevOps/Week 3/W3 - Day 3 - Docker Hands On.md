[[Docker]] [[Containers]]

## EC2 Instance 
Inside an EC2 instance you install Docker by running the command:
`sudo apt install docker.io`

You don't want to write down sudo every time you want to use Docker, so you need to add your user to the of users that can talk to Docker. 
#note -> Docker runs by another user under the hood (I think), that's why you have to grant permissions to your account

Commands needed to run:

`sudo usermod -aG docker 'ubuntu-your-user'`

You then exit the shell and restart 

After that you can talk to the client and the server

`ps -ef | grep docker` -> will give you the processes running 

## Basic commands for docker 

`docker images` -> gives you the images running in the machine 

`docker ps -a` -> processes or containers 

## Docker Hub
You can search for images here - any application that you want to create are here (base images). These applications are the foundation for your own application. You don't need to install anything inside the container
- An audit of the docker image is recommended so that you are compliant to security policies. 

## Busybox
Swiss army knife of embedded linux - this distro is extremely light weight. During the video the professor uses this as a test. If you are able to open this image it means that you can run docker and that you can access docker hub

Busybox is a small footprint tool to help you learn docker and containerization
## Starting Docker 
Start a container from the image 
`docker run --rm busybox:latest /bin/echo "Hello Docker"` 
- rm deletes the container once its done
- latest - gives you the latest version of the program

The moment you run this command, docker will check if this image exists locally, if not, docker communicates with docker hub and downloads it 

> [!You are not creating busybox]
> Important to note, when you download an image from docker hub, you don't create it. The creation is done by the developers that maintain that image. You are simply downloading it. Just as downloading/cloning code from github and using it for your project.

after you run this, you can also run `docker images` and busybox will show up there. 
- The image will sit in the machine's disk

But if you do `dokcer ps -a` you will see that there is no containers because we used the `rm` command when running the container

## Another Image 

`docker run docker/whalesay cowsay Hello Docker`

in the command `docker/whalesay` <- docker signifies the user and whalesay is the image

`cowsay` This is another argument 

`rm` is not included here, garbage collection will be performed by us.

`docker image` shows both images busybox & docker/whalesay

`docker ps -a` -> shows the container docker/whalesay that was not removed. 

You use id or names to refer to images

## Where are layers stored
*layers* -> building blocks that make up an image. Each *dockerfile* step adds a new layer. 

Command to see all layers
`sudo ls -al /var/lib/docker/aufs/layers`

- aufs -> Union file system. layer assembly package/dependency. This is installed when you install docker if you don't have it. 

## Ephemeral Containers
Horizontal elasticity is the objective - add and remove. Remove the data generated by the processes. For example you don't want customer data inside the container. #Tip: Don't save in the local file system. 

You can create multiple containers based off one image. 

If you log in to one container and make changes, the next container you build wont keep the changes set in the first container. 
- For example, the instructor created a container, logged in to it (similar to SSH but with the below command), created a folder and then created a text file within this folder. After that he exit the container, rerun another container and the folder with the text file was gone. 

`docker runb -it --rm busybox:latest`

- it gives you an interactive command line. It puts you inside the container

Be careful storing data inside the container file system


## Running an operating system inside the container that is different from the hostâ€™s operating system.

`docker run -d centos tail -f /dev/null`

- -d detach mode/daemon mode -> it will continue to run after the command is over. Keeps a container running - *long running*.

Each container is a process - within the container you have process ids. As long as the process id1 is running, it will continue to run. 
- your process id1 will always correspond to the 'nature' of the container. If you are running a tomcat container, the process id1 is tomcat. If you are running a mysql, process id1 will be my sql.
- As long as process id1 is running, your container is live and well. 

`-f /dev/null`
- Process that will never exit 

`docker ps -a` to get the container id or name 

`ps -ef | grep [d]ocker`  -> gives you the processes

`sudo kill -9 {docker process id}` -> kill a process

1) `docker run -d centos tail -f /dev/null`
2) `docker exec -it name-of-container bash` 

#note: process ID 1 is protected by Docker. If you kill the process from within the container, nothing will happen.

## Removing Images
Images take a lot of disk space

To get all layers:
`sudo ls -al /var/lib/docker/aufs/layers`

To remove images:
`docker rmi image-id`
- You might get an error running the above command.
- Before you run this you need to shut down the container: `docker stop container-name`. But as long as there is a container based on the image, docker will try its best to stop you from doing that. Even if its status is stopped on the container. However you can be forceful about this. Forcefully remove the image | This is not recommended. Command for that: `docker rmi -f image-name`
- Graceful way of doing this: `rm container-name container-name-2` then do the `docker rmi image-name`

The moment you remove an image, the corresponding layers will also 
be removed. 

You can develop shell scripts to perform clean up of layers, containers or images. You don't worry about *left over* installation. You have to try to avoid left over installations because they unnecessarily take up resources. 
## Volume Mapping
Containers can write data to the host machine 

