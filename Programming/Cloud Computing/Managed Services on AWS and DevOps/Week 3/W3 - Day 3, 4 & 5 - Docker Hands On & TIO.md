[[Docker]] [[Containers]]

## EC2 Instance 
Inside an EC2 instance you install Docker by running the command:
`sudo apt install docker.io`

You don't want to write down sudo every time you want to use Docker, so you need to add your user to the of users that can talk to Docker. 
#note -> Docker runs by another user under the hood (I think), that's why you have to grant permissions to your account

Commands needed to run:

`sudo usermod -aG docker 'ubuntu-your-user'`

You then exit the shell and restart 

After that you can talk to the client and the server

`ps -ef | grep docker` -> will give you the processes running 

## Basic commands for docker 

`docker images` -> gives you the images running in the machine 

`docker ps -a` -> processes or containers 

## Docker Hub
You can search for images here - any application that you want to create are here (base images). These applications are the foundation for your own application. You don't need to install anything inside the container
- An audit of the docker image is recommended so that you are compliant to security policies. 

## Busybox
Swiss army knife of embedded linux - this distro is extremely light weight. During the video the professor uses this as a test. If you are able to open this image it means that you can run docker and that you can access docker hub

Busybox is a small footprint tool to help you learn docker and containerization
## Starting Docker 
Start a container from the image 
`docker run --rm busybox:latest /bin/echo "Hello Docker"` 
- rm deletes the container once its done
- latest - gives you the latest version of the program

The moment you run this command, docker will check if this image exists locally, if not, docker communicates with docker hub and downloads it 

> [!You are not creating busybox]
> Important to note, when you download an image from docker hub, you don't create it. The creation is done by the developers that maintain that image. You are simply downloading it. Just as downloading/cloning code from github and using it for your project.

after you run this, you can also run `docker images` and busybox will show up there. 
- The image will sit in the machine's disk

But if you do `dokcer ps -a` you will see that there is no containers because we used the `rm` command when running the container

## Another Image 

`docker run docker/whalesay cowsay Hello Docker`

in the command `docker/whalesay` <- docker signifies the user and whalesay is the image

`cowsay` This is another argument 

`rm` is not included here, garbage collection will be performed by us.

`docker image` shows both images busybox & docker/whalesay

`docker ps -a` -> shows the container docker/whalesay that was not removed. 

You use id or names to refer to images

## Where are layers stored
*layers* -> building blocks that make up an image. Each *dockerfile* step adds a new layer. 

Command to see all layers
`sudo ls -al /var/lib/docker/aufs/layers`

- aufs -> Union file system. layer assembly package/dependency. This is installed when you install docker if you don't have it. 

## Ephemeral Containers
Horizontal elasticity is the objective - add and remove. Remove the data generated by the processes. For example you don't want customer data inside the container. #Tip: Don't save in the local file system. 

You can create multiple containers based off one image. 

If you log in to one container and make changes, the next container you build wont keep the changes set in the first container. 
- For example, the instructor created a container, logged in to it (similar to SSH but with the below command), created a folder and then created a text file within this folder. After that he exit the container, rerun another container and the folder with the text file was gone. 

`docker runb -it --rm busybox:latest`

- it gives you an interactive command line. It puts you inside the container

Be careful storing data inside the container file system


## Running an operating system inside the container that is different from the host’s operating system.

`docker run -d centos tail -f /dev/null`

- -d detach mode/daemon mode -> it will continue to run after the command is over. Keeps a container running - *long running*.
	- Runs the container in the background instead of attaching it to your terminal

Each container is a process - within the container you have process ids. As long as the process id1 is running, it will continue to run. 
- your process id1 will always correspond to the 'nature' of the container. If you are running a tomcat container, the process id1 is tomcat. If you are running a mysql, process id1 will be my sql.
- As long as process id1 is running, your container is live and well. 

`-f /dev/null`
- Process that will never exit 

`docker ps -a` to get the container id or name 

`ps -ef | grep [d]ocker`  -> gives you the processes

`sudo kill -9 {docker process id}` -> kill a process

1) `docker run -d centos tail -f /dev/null`
2) `docker exec -it name-of-container bash` 

#note: process ID 1 is protected by Docker. If you kill the process from within the container, nothing will happen.

## Removing Images
Images take a lot of disk space

To get all layers:
`sudo ls -al /var/lib/docker/aufs/layers`

To remove images:
`docker rmi image-id`
- You might get an error running the above command.
- Before you run this you need to shut down the container: `docker stop container-name`. But as long as there is a container based on the image, docker will try its best to stop you from doing that. Even if its status is stopped on the container. However you can be forceful about this. Forcefully remove the image | This is not recommended. Command for that: `docker rmi -f image-name`
- Graceful way of doing this: `rm container-name container-name-2` then do the `docker rmi image-name`

The moment you remove an image, the corresponding layers will also 
be removed. 

You can develop shell scripts to perform clean up of layers, containers or images. You don't worry about *left over* installation. You have to try to avoid left over installations because they unnecessarily take up resources. 
## Volume Mapping
Containers can write data to the host machine 

# TIO

## EC2
We start by creating an EC2 instance with ubuntu - t2.small instance type. 

For network security, we created a security group that allows traffic from anywhere for port 22 (ssh) and port 80 for http

I did a copy of the .pem file in my remotessd into the learning folder in my mac with `cp [source] [destination]` and then I was able to ssh into the instance I created. 

then got the install script from:
`wget https://d6opu47qoi4ee.cloudfront.net/dockerinstallscript.sh`

and ran it with:
`bash dockerinstallscript.sh`

Same as python, you can check it it was correctly installed if you do a version check with:
`docker version`

we installed busybox and printed a simple hello world

### Working with images and containers
We started running the following commands:

```bash
sudo chown ubuntu:ubuntu -R /opt
cd /opt
docker images
docker run --rm busybox:latest /bin/echo "Hello world"
wget https://d6opu47qoi4ee.cloudfront.net/project-container/Dockerfile
docker build -t helloworld .
docker run -d -p 80:8080 helloworld
docker ps -a
```


container id -> 75e8275f231e


line 1) changes the owner and group to ubuntu (us)
2) changes directory
3) lists images
4) runs the busybox to print hello world
5) pulls a folder from the web on how to build the image helloworld
6) builds an image from the dockerfile we downloaded and tags the image as helloworld for easier reference
7) runs the helloworld image in the background (-d) and -p maps the port 80 to port 8080
	1) **Containers run in an isolated network — they have their own private network space. To communicate with a container from outside, you need to expose a port and map it to a port on the host machine. In `-p 80:8080`, port 8080 is where the app inside the container is listening, and port 80 is the entry point on the host. Any request to port 80 on the host is forwarded to port 8080 inside the container.**

### Entering the EC2's DNS into a browser
I enter http://44.204.175.58/ into the browser, which is the EC2's instance DNS. Whenever I do that I am performing an HTTP request - the inbound rule we created in the security group. Since it's going through port 80, it will be forwarded to the 8080 port in the container giving us the tomcat server we opened through the container

# Wordl TIO

We launch an instance - name and tags are set by me. Ubuntu 22.04 LTS 

For this TIO an instsance type of T2.medium is needed. 

We open port 22 for ssh and 80 for http

we launch the instance and we install docker - first wget link then run bash script, then exit to restart instance

After the restart with run these commands

```
sudo apt update
sudo apt install unzip
sudo chown ubuntu:ubuntu -R /opt
cd /opt
wget https://d6opu47qoi4ee.cloudfront.net/reactle.zip
unzip reactle.zip
docker build -t reactle .
docker run -d -p 80:80 reactle
```

